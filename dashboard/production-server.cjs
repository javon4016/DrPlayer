#!/usr/bin/env node
/**
 * Áîü‰∫ßÊúçÂä°Âô® - DrPlayer Dashboard (CommonJSÁâàÊú¨ÔºåÁî®‰∫éPKGÊâìÂåÖ)
 */

const Fastify = require('fastify');
const fastifyStatic = require('@fastify/static');
const path = require('path');
const fs = require('fs/promises');
const { execSync } = require('child_process');
const net = require('net');

// ÂÜÖËÅî SPA Ë∑ØÁî±ÂäüËÉΩ (ÈÅøÂÖçES6Ê®°Âùó‰æùËµñ)
async function addSPARoutes(fastify, options) {
    const spaApps = options.spaApps || ['drplayer'];
    
    for (const appName of spaApps) {
        fastify.get(`/apps/${appName}`, async (request, reply) => {
            return reply.redirect(301, `/apps/${appName}/`);
        });

        fastify.get(`/apps/${appName}/`, async (request, reply) => {
            const indexPath = path.join(options.appsDir, appName, 'index.html');
            
            try {
                const indexContent = await fs.readFile(indexPath, 'utf8');
                return reply
                    .type('text/html')
                    .header('Cache-Control', 'no-cache, no-store, must-revalidate')
                    .send(indexContent);
            } catch (error) {
                return reply.code(404).send({ error: `${appName} application not found` });
            }
        });
    }

    fastify.setNotFoundHandler(async (request, reply) => {
        const url = request.url;
        
        for (const appName of spaApps) {
            const appPrefix = `/apps/${appName}/`;
            
            if (url.startsWith(appPrefix)) {
                const urlPath = url.replace(appPrefix, '');
                const hasExtension = /\.[a-zA-Z0-9]+(\?.*)?$/.test(urlPath);
                
                if (!hasExtension) {
                    const indexPath = path.join(options.appsDir, appName, 'index.html');
                    
                    try {
                        const indexContent = await fs.readFile(indexPath, 'utf8');
                        return reply
                            .type('text/html')
                            .header('Cache-Control', 'no-cache, no-store, must-revalidate')
                            .send(indexContent);
                    } catch (error) {
                        return reply.code(404).send({ error: `${appName} application not found` });
                    }
                }
            }
        }
        
        return reply.code(404).send({ error: 'Not Found' });
    });
}

// PKG ÁéØÂ¢É‰∏ãÁöÑË∑ØÂæÑÂ§ÑÁêÜ
const isPkg = typeof process.pkg !== 'undefined';

// Âú®CommonJS‰∏≠Ôºå__filenameÂíå__dirnameÊòØÂÖ®Â±ÄÂèØÁî®ÁöÑ
// Âú®PKGÁéØÂ¢É‰∏≠ÈúÄË¶ÅÈáçÊñ∞ÂÆö‰πâ
let currentFilename, currentDirname;

if (isPkg) {
    currentFilename = process.execPath;
    currentDirname = path.dirname(process.execPath);
} else {
    currentFilename = __filename;
    currentDirname = __dirname;
}

// Ê£ÄÊü•Á´ØÂè£ÊòØÂê¶ÂèØÁî®
function checkPortAvailable(port) {
    return new Promise((resolve) => {
        const server = net.createServer();
        let resolved = false;
        
        // ËÆæÁΩÆË∂ÖÊó∂Êú∫Âà∂
        const timeout = setTimeout(() => {
            if (!resolved) {
                resolved = true;
                server.close();
                resolve(false);
            }
        }, 1000);
        
        server.listen(port, '0.0.0.0', () => {
            if (!resolved) {
                resolved = true;
                clearTimeout(timeout);
                server.close(() => {
                    resolve(true);
                });
            }
        });
        
        server.on('error', (err) => {
            if (!resolved) {
                resolved = true;
                clearTimeout(timeout);
                resolve(false);
            }
        });
    });
}

// Êü•ÊâæÂèØÁî®Á´ØÂè£
async function findAvailablePort(startPort = 9978, maxAttempts = 100) {
    for (let i = 0; i < maxAttempts; i++) {
        const port = startPort + i;
        const isAvailable = await checkPortAvailable(port);
        if (isAvailable) {
            return port;
        }
        console.log(`Á´ØÂè£ ${port} Â∑≤Ë¢´Âç†Áî®ÔºåÂ∞ùËØï‰∏ã‰∏Ä‰∏™Á´ØÂè£...`);
    }
    throw new Error(`Êó†Ê≥ïÊâæÂà∞ÂèØÁî®Á´ØÂè£ÔºåÂ∑≤Â∞ùËØï ${startPort} Âà∞ ${startPort + maxAttempts - 1}`);
}

// PKG ÁéØÂ¢É‰∏ãÁöÑÂ∑•‰ΩúÁõÆÂΩïÂ§ÑÁêÜ
let workDir;
if (isPkg) {
    workDir = process.cwd();
    console.log('PKG ÁéØÂ¢ÉÊ£ÄÊµãÂà∞ÔºåÂ∑•‰ΩúÁõÆÂΩï:', workDir);
    console.log('ÂèØÊâßË°åÊñá‰ª∂Ë∑ØÂæÑ:', process.execPath);
} else {
    workDir = currentDirname;
}

// ÊûÑÂª∫ÂíåÈÉ®ÁΩ≤ÂáΩÊï∞
async function buildAndDeploy() {
    console.log('üî® ÂºÄÂßãÊûÑÂª∫Â∫îÁî®...');
    
    try {
        if (!isPkg) {
            try {
                execSync('pnpm build:apps', { stdio: 'inherit', cwd: currentDirname });
                console.log('‚úÖ ÊûÑÂª∫ÂÆåÊàê');
            } catch (buildError) {
                console.warn('‚ö†Ô∏è ÊûÑÂª∫ÂëΩ‰ª§ÊâßË°åÂ§±Ë¥•ÔºåÂèØËÉΩÊòØÂú®ÊâìÂåÖÁéØÂ¢É‰∏≠ËøêË°å:', buildError.message);
                console.log('üì¶ Ë∑≥ËøáÊûÑÂª∫Ê≠•È™§Ôºå‰ΩøÁî®È¢ÑÊûÑÂª∫ÁöÑÊñá‰ª∂');
            }
        } else {
            console.log('üì¶ Ê£ÄÊµãÂà∞pkgÁéØÂ¢ÉÔºåË∑≥ËøáÊûÑÂª∫Ê≠•È™§');
        }
        
        const appsDir = path.join(workDir, 'apps');
        const drplayerDir = path.join(appsDir, 'drplayer');
        
        await fs.mkdir(drplayerDir, { recursive: true });
        console.log('üìÅ ÂàõÂª∫appsÁõÆÂΩï');
        
        const distDir = path.join(workDir, 'dist');
        try {
            await fs.access(distDir);
            await copyDirectory(distDir, drplayerDir);
            console.log('üìã Â§çÂà∂Êñá‰ª∂Âà∞apps/drplayer');
        } catch (error) {
            console.warn('‚ö†Ô∏è distÁõÆÂΩï‰∏çÂ≠òÂú®ÔºåË∑≥ËøáÊñá‰ª∂Â§çÂà∂');
            if (isPkg) {
                console.log('üì¶ pkgÁéØÂ¢É‰∏≠ÔºåËØ∑Á°Æ‰øùÈùôÊÄÅÊñá‰ª∂Â∑≤Ê≠£Á°ÆÊâìÂåÖ');
            }
        }
        
    } catch (error) {
        console.error('‚ùå ÊûÑÂª∫Â§±Ë¥•:', error.message);
        if (typeof process.pkg === 'undefined') {
            process.exit(1);
        } else {
            console.log('üì¶ pkgÁéØÂ¢É‰∏≠ÁªßÁª≠ËøêË°å...');
        }
    }
}

// ÈÄíÂΩíÂ§çÂà∂ÁõÆÂΩï
async function copyDirectory(src, dest) {
    await fs.mkdir(dest, { recursive: true });
    const entries = await fs.readdir(src, { withFileTypes: true });
    
    for (const entry of entries) {
        const srcPath = path.join(src, entry.name);
        const destPath = path.join(dest, entry.name);
        
        if (entry.isDirectory()) {
            await copyDirectory(srcPath, destPath);
        } else {
            await fs.copyFile(srcPath, destPath);
        }
    }
}

// ‰∏ªÂáΩÊï∞
async function main() {
    const fastify = Fastify({
        logger: false
    });

    let PORT = 9978;

    // PKGÁéØÂ¢É‰∏≠ÁöÑÈùôÊÄÅÊñá‰ª∂Ë∑ØÂæÑÂ§ÑÁêÜ
    let appsDir;
    if (isPkg) {
        // PKGÁéØÂ¢É‰∏≠ÔºåÈùôÊÄÅÊñá‰ª∂Âú®Â∑•‰ΩúÁõÆÂΩï‰∏ãÁöÑappsÁõÆÂΩï
        appsDir = path.join(workDir, 'apps');
        console.log('üì¶ PKGÁéØÂ¢É‰∏≠‰ΩøÁî®Â∑•‰ΩúÁõÆÂΩïÁöÑÈùôÊÄÅÊñá‰ª∂Ë∑ØÂæÑ:', appsDir);
    } else {
        // ÂºÄÂèëÁéØÂ¢É‰∏≠‰ΩøÁî®Â∑•‰ΩúÁõÆÂΩï
        appsDir = path.join(workDir, 'apps');
        console.log('üîß ÂºÄÂèëÁéØÂ¢É‰∏≠‰ΩøÁî®Â∑•‰ΩúÁõÆÂΩï:', appsDir);
    }

    const options = {
        appsDir: appsDir,
        port: PORT
    };

    // Ê≥®ÂÜåÈùôÊÄÅÊñá‰ª∂ÊúçÂä°
    await fastify.register(fastifyStatic, {
        root: options.appsDir,
        prefix: '/apps/',
        decorateReply: false,
    });

    // Ê≥®ÂÜåSPAË∑ØÁî±ÊîØÊåÅ
    await fastify.register(addSPARoutes, {
        appsDir: options.appsDir,
        spaApps: ['drplayer']
    });

    // Ê†πË∑ØÂæÑ - ÊòæÁ§∫Â∫îÁî®ÂàóË°®
    fastify.get('/', async (request, reply) => {
        let version = '1.0.0';
        try {
            const packageJsonPath = path.join(currentDirname, 'package.json');
            const packageJsonContent = await fs.readFile(packageJsonPath, 'utf8');
            const packageJson = JSON.parse(packageJsonContent);
            version = packageJson.version || '1.0.0';
        } catch (error) {
            console.warn('Êó†Ê≥ïËØªÂèñpackage.jsonÁâàÊú¨‰ø°ÊÅØ:', error.message);
        }
        
        const html = `
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DrPlayer Dashboard</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 40px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 40px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        .apps-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        .app-card {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            text-decoration: none;
            color: #495057;
            transition: all 0.3s ease;
        }
        .app-card:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.2);
        }
        .app-name {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 8px;
            color: #2c3e50;
        }
        .app-description {
            font-size: 0.9em;
            color: #6c757d;
        }
        .status {
            margin-top: 30px;
            padding: 15px;
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 6px;
            color: #155724;
        }
        .footer {
            text-align: center;
            margin-top: 40px;
            color: #6c757d;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé¨ DrPlayer Dashboard</h1>
        
        <div class="status">
            <strong>‚úÖ ÊúçÂä°Âô®ËøêË°åÊ≠£Â∏∏</strong> - Á´ØÂè£: ${PORT}
        </div>
        
        <div class="apps-grid">
            <a href="/apps/drplayer/" class="app-card">
                <div class="app-name">DrPlayer</div>
                <div class="app-description">ËßÜÈ¢ëÊí≠ÊîæÂô®ÁÆ°ÁêÜÁïåÈù¢</div>
            </a>
        </div>
        
        <div class="footer">
            <p>ÂÅ•Â∫∑Ê£ÄÊü•: <a href="/health">/health</a></p>
            <p>DrPlayer Dashboard v${version}</p>
        </div>
    </div>
</body>
</html>`;
        
        return reply.type('text/html').send(html);
    });

    // ÂÅ•Â∫∑Ê£ÄÊü•
    fastify.get('/health', async (request, reply) => {
        return {status: 'ok', timestamp: new Date().toISOString()};
    });

    // ÂêØÂä®ÊúçÂä°Âô®
    const start = async () => {
        try {
            await buildAndDeploy();
            
            console.log(`üîç Ê≠£Âú®Êü•ÊâæÂèØÁî®Á´ØÂè£ÔºåËµ∑ÂßãÁ´ØÂè£: ${PORT}`);
            const availablePort = await findAvailablePort(PORT);
            PORT = availablePort;
            options.port = PORT;
            
            console.log(`‚úÖ ÊâæÂà∞ÂèØÁî®Á´ØÂè£: ${PORT}`);
            
            await fastify.listen({ port: PORT, host: '0.0.0.0' });
            console.log(`üöÄ Áîü‰∫ßÊúçÂä°Âô®ÂêØÂä®ÊàêÂäüÔºÅ`);
            console.log(`üì± ËÆøÈóÆÂú∞ÂùÄ: http://localhost:${PORT}/apps/drplayer/`);
            console.log(`üîç ÂÅ•Â∫∑Ê£ÄÊü•: http://localhost:${PORT}/health`);
            console.log(`üì¶ ËøêË°åÁéØÂ¢É: ${isPkg ? 'PKG‰∫åËøõÂà∂' : 'ÂºÄÂèëÁéØÂ¢É'}`);
            
            if (isPkg) {
                console.log(`üìÅ Â∑•‰ΩúÁõÆÂΩï: ${workDir}`);
                console.log(`üìÇ Â∫îÁî®ÁõÆÂΩï: ${options.appsDir}`);
            }
            
        } catch (err) {
            console.error('‚ùå ÊúçÂä°Âô®ÂêØÂä®Â§±Ë¥•:', err.message);
            fastify.log.error(err);
            process.exit(1);
        }
    };

    // ‰ºòÈõÖÂÖ≥Èó≠
    process.on('SIGINT', async () => {
        console.log('\nüõë Ê≠£Âú®ÂÖ≥Èó≠ÊúçÂä°Âô®...');
        await fastify.close();
        process.exit(0);
    });

    await start();
}

// ÂêØÂä®Â∫îÁî®
main().catch(console.error);